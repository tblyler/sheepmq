// Code generated by protoc-gen-go. DO NOT EDIT.
// source: shepard.proto

/*
Package shepard is a generated protocol buffer package.

It is generated from these files:
	shepard.proto

It has these top-level messages:
	Response
	Item
	GetInfo
	TimeLease
	PidLease
	HeartbeatLease
	DelInfo
	ErrInfo
*/
package shepard

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Response struct {
	// whether or not the operation was successful
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	// the amount of items affected
	Count uint64 `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	// error message on failure
	Msg string `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Response) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Response) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type Item struct {
	// the id for this item
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// the arbitrary data for this item
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// the queue for this item
	Queue string `protobuf:"bytes,3,opt,name=queue" json:"queue,omitempty"`
	// error queue to cycle items to
	ErrorQueue string `protobuf:"bytes,4,opt,name=errorQueue" json:"errorQueue,omitempty"`
	// error queue TTL in nanoseconds
	ErrorTTL int64 `protobuf:"fixed64,5,opt,name=errorTTL" json:"errorTTL,omitempty"`
	// the Unix time (in seconds) in which this item was created
	Ctime int64 `protobuf:"fixed64,6,opt,name=ctime" json:"ctime,omitempty"`
	// the Unix time (in seconds) in which this item was errored last
	Etime int64 `protobuf:"fixed64,7,opt,name=etime" json:"etime,omitempty"`
	// the amount of times this item was errored
	Ecount uint32 `protobuf:"varint,8,opt,name=ecount" json:"ecount,omitempty"`
	// arbitrary statistical sizes to record for this item
	Stats map[string]int64 `protobuf:"bytes,9,rep,name=stats" json:"stats,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Item) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Item) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Item) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *Item) GetErrorQueue() string {
	if m != nil {
		return m.ErrorQueue
	}
	return ""
}

func (m *Item) GetErrorTTL() int64 {
	if m != nil {
		return m.ErrorTTL
	}
	return 0
}

func (m *Item) GetCtime() int64 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *Item) GetEtime() int64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *Item) GetEcount() uint32 {
	if m != nil {
		return m.Ecount
	}
	return 0
}

func (m *Item) GetStats() map[string]int64 {
	if m != nil {
		return m.Stats
	}
	return nil
}

type GetInfo struct {
	Queue string `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	// the amount of items to try and pull
	Count        uint64          `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	TimeoutLease *TimeLease      `protobuf:"bytes,3,opt,name=timeoutLease" json:"timeoutLease,omitempty"`
	PidLease     *PidLease       `protobuf:"bytes,4,opt,name=pidLease" json:"pidLease,omitempty"`
	HeartLease   *HeartbeatLease `protobuf:"bytes,5,opt,name=heartLease" json:"heartLease,omitempty"`
}

func (m *GetInfo) Reset()                    { *m = GetInfo{} }
func (m *GetInfo) String() string            { return proto.CompactTextString(m) }
func (*GetInfo) ProtoMessage()               {}
func (*GetInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetInfo) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *GetInfo) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetInfo) GetTimeoutLease() *TimeLease {
	if m != nil {
		return m.TimeoutLease
	}
	return nil
}

func (m *GetInfo) GetPidLease() *PidLease {
	if m != nil {
		return m.PidLease
	}
	return nil
}

func (m *GetInfo) GetHeartLease() *HeartbeatLease {
	if m != nil {
		return m.HeartLease
	}
	return nil
}

type TimeLease struct {
	// TTL in nanoseconds to hold the lease
	Ttl int64 `protobuf:"fixed64,1,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *TimeLease) Reset()                    { *m = TimeLease{} }
func (m *TimeLease) String() string            { return proto.CompactTextString(m) }
func (*TimeLease) ProtoMessage()               {}
func (*TimeLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TimeLease) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type PidLease struct {
	Pid uint32 `protobuf:"varint,1,opt,name=pid" json:"pid,omitempty"`
}

func (m *PidLease) Reset()                    { *m = PidLease{} }
func (m *PidLease) String() string            { return proto.CompactTextString(m) }
func (*PidLease) ProtoMessage()               {}
func (*PidLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PidLease) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type HeartbeatLease struct {
	Id  string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Ttl int64  `protobuf:"fixed64,2,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *HeartbeatLease) Reset()                    { *m = HeartbeatLease{} }
func (m *HeartbeatLease) String() string            { return proto.CompactTextString(m) }
func (*HeartbeatLease) ProtoMessage()               {}
func (*HeartbeatLease) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *HeartbeatLease) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *HeartbeatLease) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type DelInfo struct {
	Queue string   `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	Ids   []uint64 `protobuf:"varint,2,rep,packed,name=ids" json:"ids,omitempty"`
}

func (m *DelInfo) Reset()                    { *m = DelInfo{} }
func (m *DelInfo) String() string            { return proto.CompactTextString(m) }
func (*DelInfo) ProtoMessage()               {}
func (*DelInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DelInfo) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *DelInfo) GetIds() []uint64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

type ErrInfo struct {
	Queue string   `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	Ids   []uint64 `protobuf:"varint,2,rep,packed,name=ids" json:"ids,omitempty"`
}

func (m *ErrInfo) Reset()                    { *m = ErrInfo{} }
func (m *ErrInfo) String() string            { return proto.CompactTextString(m) }
func (*ErrInfo) ProtoMessage()               {}
func (*ErrInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ErrInfo) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *ErrInfo) GetIds() []uint64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func init() {
	proto.RegisterType((*Response)(nil), "shepard.Response")
	proto.RegisterType((*Item)(nil), "shepard.Item")
	proto.RegisterType((*GetInfo)(nil), "shepard.GetInfo")
	proto.RegisterType((*TimeLease)(nil), "shepard.TimeLease")
	proto.RegisterType((*PidLease)(nil), "shepard.PidLease")
	proto.RegisterType((*HeartbeatLease)(nil), "shepard.HeartbeatLease")
	proto.RegisterType((*DelInfo)(nil), "shepard.DelInfo")
	proto.RegisterType((*ErrInfo)(nil), "shepard.ErrInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Sheepmq service

type SheepmqClient interface {
	// Add the given items to the queue
	AddItem(ctx context.Context, opts ...grpc.CallOption) (Sheepmq_AddItemClient, error)
	// Get the given items per the info provided
	GetItem(ctx context.Context, in *GetInfo, opts ...grpc.CallOption) (Sheepmq_GetItemClient, error)
	// Delete the given items if possible
	DelItem(ctx context.Context, in *DelInfo, opts ...grpc.CallOption) (*Response, error)
	// Error the given items if possible
	ErrItem(ctx context.Context, in *ErrInfo, opts ...grpc.CallOption) (*Response, error)
}

type sheepmqClient struct {
	cc *grpc.ClientConn
}

func NewSheepmqClient(cc *grpc.ClientConn) SheepmqClient {
	return &sheepmqClient{cc}
}

func (c *sheepmqClient) AddItem(ctx context.Context, opts ...grpc.CallOption) (Sheepmq_AddItemClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Sheepmq_serviceDesc.Streams[0], c.cc, "/shepard.sheepmq/AddItem", opts...)
	if err != nil {
		return nil, err
	}
	x := &sheepmqAddItemClient{stream}
	return x, nil
}

type Sheepmq_AddItemClient interface {
	Send(*Item) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type sheepmqAddItemClient struct {
	grpc.ClientStream
}

func (x *sheepmqAddItemClient) Send(m *Item) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sheepmqAddItemClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sheepmqClient) GetItem(ctx context.Context, in *GetInfo, opts ...grpc.CallOption) (Sheepmq_GetItemClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Sheepmq_serviceDesc.Streams[1], c.cc, "/shepard.sheepmq/GetItem", opts...)
	if err != nil {
		return nil, err
	}
	x := &sheepmqGetItemClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Sheepmq_GetItemClient interface {
	Recv() (*Item, error)
	grpc.ClientStream
}

type sheepmqGetItemClient struct {
	grpc.ClientStream
}

func (x *sheepmqGetItemClient) Recv() (*Item, error) {
	m := new(Item)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sheepmqClient) DelItem(ctx context.Context, in *DelInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/shepard.sheepmq/DelItem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sheepmqClient) ErrItem(ctx context.Context, in *ErrInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/shepard.sheepmq/ErrItem", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Sheepmq service

type SheepmqServer interface {
	// Add the given items to the queue
	AddItem(Sheepmq_AddItemServer) error
	// Get the given items per the info provided
	GetItem(*GetInfo, Sheepmq_GetItemServer) error
	// Delete the given items if possible
	DelItem(context.Context, *DelInfo) (*Response, error)
	// Error the given items if possible
	ErrItem(context.Context, *ErrInfo) (*Response, error)
}

func RegisterSheepmqServer(s *grpc.Server, srv SheepmqServer) {
	s.RegisterService(&_Sheepmq_serviceDesc, srv)
}

func _Sheepmq_AddItem_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SheepmqServer).AddItem(&sheepmqAddItemServer{stream})
}

type Sheepmq_AddItemServer interface {
	Send(*Response) error
	Recv() (*Item, error)
	grpc.ServerStream
}

type sheepmqAddItemServer struct {
	grpc.ServerStream
}

func (x *sheepmqAddItemServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sheepmqAddItemServer) Recv() (*Item, error) {
	m := new(Item)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Sheepmq_GetItem_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetInfo)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SheepmqServer).GetItem(m, &sheepmqGetItemServer{stream})
}

type Sheepmq_GetItemServer interface {
	Send(*Item) error
	grpc.ServerStream
}

type sheepmqGetItemServer struct {
	grpc.ServerStream
}

func (x *sheepmqGetItemServer) Send(m *Item) error {
	return x.ServerStream.SendMsg(m)
}

func _Sheepmq_DelItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SheepmqServer).DelItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shepard.sheepmq/DelItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SheepmqServer).DelItem(ctx, req.(*DelInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sheepmq_ErrItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SheepmqServer).ErrItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shepard.sheepmq/ErrItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SheepmqServer).ErrItem(ctx, req.(*ErrInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _Sheepmq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "shepard.sheepmq",
	HandlerType: (*SheepmqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DelItem",
			Handler:    _Sheepmq_DelItem_Handler,
		},
		{
			MethodName: "ErrItem",
			Handler:    _Sheepmq_ErrItem_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AddItem",
			Handler:       _Sheepmq_AddItem_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetItem",
			Handler:       _Sheepmq_GetItem_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "shepard.proto",
}

func init() { proto.RegisterFile("shepard.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 518 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xed, 0xda, 0x4e, 0xec, 0x4c, 0x9a, 0xca, 0xac, 0x10, 0x58, 0x11, 0x20, 0xcb, 0x27, 0x5f,
	0x88, 0x42, 0x90, 0x68, 0xc5, 0x0d, 0x89, 0x0a, 0x1a, 0xe5, 0x00, 0x4b, 0x7e, 0xc0, 0x8d, 0x07,
	0x6a, 0x11, 0xc7, 0xae, 0x77, 0x8d, 0xd4, 0xbf, 0xe2, 0x53, 0xb8, 0xf3, 0x33, 0x68, 0x76, 0x37,
	0x4e, 0x2c, 0x45, 0x48, 0xbd, 0xcd, 0x9b, 0x99, 0x37, 0xe3, 0xf7, 0x32, 0x1b, 0x98, 0xc8, 0x3b,
	0xac, 0xb3, 0x26, 0x9f, 0xd5, 0x4d, 0xa5, 0x2a, 0xee, 0x5b, 0x98, 0xac, 0x20, 0x10, 0x28, 0xeb,
	0x6a, 0x27, 0x91, 0x47, 0xe0, 0xcb, 0x76, 0xb3, 0x41, 0x29, 0x23, 0x16, 0xb3, 0x34, 0x10, 0x7b,
	0xc8, 0x9f, 0xc2, 0x60, 0x53, 0xb5, 0x3b, 0x15, 0x39, 0x31, 0x4b, 0x3d, 0x61, 0x00, 0x0f, 0xc1,
	0x2d, 0xe5, 0x8f, 0xc8, 0x8d, 0x59, 0x3a, 0x12, 0x14, 0x26, 0xbf, 0x1d, 0xf0, 0x6e, 0x14, 0x96,
	0xfc, 0x02, 0x9c, 0x22, 0xd7, 0x53, 0x3c, 0xe1, 0x14, 0x39, 0xe7, 0xe0, 0xe5, 0x99, 0xca, 0x34,
	0xff, 0x5c, 0xe8, 0x98, 0x86, 0xde, 0xb7, 0xd8, 0xa2, 0x1d, 0x60, 0x00, 0x7f, 0x05, 0x80, 0x4d,
	0x53, 0x35, 0x5f, 0x75, 0xc9, 0xd3, 0xa5, 0xa3, 0x0c, 0x9f, 0x42, 0xa0, 0xd1, 0x7a, 0xbd, 0x8a,
	0x06, 0x31, 0x4b, 0x43, 0xd1, 0x61, 0xfd, 0x99, 0xaa, 0x28, 0x31, 0x1a, 0xea, 0x82, 0x01, 0x94,
	0x45, 0x9d, 0xf5, 0x4d, 0x56, 0x03, 0xfe, 0x0c, 0x86, 0x68, 0x34, 0x05, 0x31, 0x4b, 0x27, 0xc2,
	0x22, 0x3e, 0x83, 0x81, 0x54, 0x99, 0x92, 0xd1, 0x28, 0x76, 0xd3, 0xf1, 0x22, 0x9a, 0xed, 0x8d,
	0x23, 0x5d, 0xb3, 0x6f, 0x54, 0xba, 0xde, 0xa9, 0xe6, 0x41, 0x98, 0xb6, 0xe9, 0x15, 0xc0, 0x21,
	0x49, 0x96, 0xfc, 0xc4, 0x07, 0x2d, 0x7c, 0x24, 0x28, 0xa4, 0xed, 0xbf, 0xb2, 0x6d, 0x8b, 0x5a,
	0xba, 0x2b, 0x0c, 0x78, 0xef, 0x5c, 0xb1, 0xa5, 0x17, 0x40, 0x18, 0x26, 0x7f, 0x19, 0xf8, 0x9f,
	0x50, 0xdd, 0xec, 0xbe, 0x57, 0x07, 0x47, 0xd8, 0xb1, 0x23, 0xa7, 0xcd, 0x7f, 0x07, 0xe7, 0xa4,
	0xa3, 0x6a, 0xd5, 0x0a, 0x33, 0x69, 0x4c, 0x1c, 0x2f, 0x78, 0xf7, 0xb9, 0xeb, 0xa2, 0x44, 0x5d,
	0x11, 0xbd, 0x3e, 0xfe, 0x1a, 0x82, 0xba, 0xc8, 0x0d, 0xc7, 0xd3, 0x9c, 0x27, 0x1d, 0xe7, 0x8b,
	0x2d, 0x88, 0xae, 0x85, 0x5f, 0x02, 0xdc, 0x61, 0xd6, 0xd8, 0x25, 0x03, 0x4d, 0x78, 0xde, 0x11,
	0x3e, 0x53, 0xe9, 0x16, 0x33, 0x53, 0x16, 0x47, 0xad, 0x4b, 0x2f, 0x18, 0x86, 0xe3, 0xe4, 0x25,
	0x8c, 0xba, 0x0f, 0x21, 0x73, 0x94, 0xda, 0x6a, 0x71, 0xa1, 0xa0, 0x30, 0x79, 0x01, 0xc1, 0x7e,
	0x27, 0x55, 0x6b, 0x7b, 0x33, 0x13, 0x41, 0x61, 0xb2, 0x80, 0x8b, 0xfe, 0x82, 0xa3, 0xb3, 0x1a,
	0xe9, 0xb3, 0xb2, 0x13, 0x9d, 0xc3, 0xc4, 0x4b, 0xf0, 0x3f, 0xe2, 0xf6, 0x3f, 0x6e, 0x86, 0xe0,
	0x16, 0xb9, 0x8c, 0x9c, 0xd8, 0x4d, 0x3d, 0x41, 0xe1, 0xd2, 0x0b, 0xdc, 0x70, 0x4c, 0xc4, 0xeb,
	0xa6, 0x79, 0x3c, 0x71, 0xf1, 0x87, 0x01, 0xbd, 0x26, 0xac, 0xcb, 0x7b, 0xfe, 0x06, 0xfc, 0x0f,
	0x79, 0xae, 0x5f, 0xc0, 0xa4, 0x77, 0x38, 0xd3, 0x83, 0xc9, 0xfb, 0xe7, 0x96, 0x9c, 0xa5, 0x6c,
	0xce, 0xf8, 0xcc, 0xfc, 0xfc, 0x44, 0x09, 0xbb, 0x1e, 0x7b, 0x10, 0xd3, 0xfe, 0x90, 0xe4, 0x6c,
	0xce, 0xf8, 0xdc, 0x08, 0xec, 0xf7, 0x5b, 0xc9, 0x27, 0xb7, 0x10, 0x83, 0x94, 0xf5, 0x19, 0x56,
	0xeb, 0x49, 0xc6, 0xed, 0x50, 0xff, 0x49, 0xbc, 0xfd, 0x17, 0x00, 0x00, 0xff, 0xff, 0x85, 0xe5,
	0x0d, 0x44, 0x35, 0x04, 0x00, 0x00,
}
